"""
UI Framework Generator (Phase 5.4.2 ‚Äî Multi-Browser + Auth-Ready + TS/JS switch)
--------------------------------------------------------------------------------
Generates an isolated Playwright workspace from an AI-generated plan.

Features:
- TypeScript by default (can be switched to JS via output_type="js")
- Per-run workspace isolation (timestamped folders)
- Copies auth/session_state into workspace and injects storageState into config
- Writes tests (.spec.ts or .spec.js) using SemanticActionEngine.generate_js_action
- Bootstraps workspace-local package.json and installs @playwright/test
- Best-practice files: tsconfig.json (for TS), README, workspace-metadata.json
"""

import os
import uuid
import re
import shutil
import subprocess
import json
from datetime import datetime
from jinja2 import Template
from typing import Optional

from modules.semantic_action_engine import SemanticActionEngine
from modules.auth_manager import AuthManager

ROOT_OUT = "generated_ui_framework"
DEFAULT_SESSION_RELPATH = "auth/session_state.json"

# ---------- Templates ----------
PLAYWRIGHT_CONFIG_TEMPLATE = """
// @ts-check
const { defineConfig } = require('@playwright/test');
const path = require('path');

const browserMatrix = (process.env.BROWSERS || 'chromium,firefox,webkit')
  .split(',')
  .map(b => b.trim())
  .filter(Boolean);

const projects = browserMatrix.map(browserName => ({
  name: browserName,
  use: { browserName }
}));

module.exports = defineConfig({
  testDir: './tests',
  timeout: 45000,
  expect: { timeout: 8000 },
  reporter: [
    ['html', { outputFolder: path.resolve(__dirname, './reports/playwright'), open: 'never' }],
    ['json', { outputFile: path.resolve(__dirname, './reports/playwright/report.json') }]
  ],
  projects,
  use: {
    baseURL: '{{ base_url }}',
    {{ storage_state_line }}
    trace: 'retain-on-failure',
    video: 'retain-on-failure',
    screenshot: 'only-on-failure',
    headless: true,
  },
});
"""

TEST_TEMPLATE_TS = """
import { test, expect } from '@playwright/test';
import fs from 'fs';
import path from 'path';

// workspace-local logs
const LOG_DIR = path.resolve(process.cwd(), 'reports/step_logs');
if (!fs.existsSync(LOG_DIR)) fs.mkdirSync(LOG_DIR, { recursive: true });

async function logStep(page, stepId, description, status, takeScreenshot = false) {
  const timestamp = new Date().toISOString();
  console.log(`üìò [${timestamp}] [${status}] [STEP ${stepId}] ${description}`);
  fs.writeFileSync(path.join(LOG_DIR, `${stepId}_${status}.txt`), `[${timestamp}] ${status}: ${description}`);
  if (takeScreenshot) {
    try {
      await page.screenshot({ path: path.join(LOG_DIR, `${stepId}_${status}.png`), fullPage: true });
    } catch (e) {
      console.warn('Screenshot failed', e);
    }
  }
}

test.describe('{{ suite_name }} suite', () => {
{% for c in cases %}
  test('{{ c.name }}', async ({ page }) => {
{% for s in c.steps %}
    // ---- STEP {{ s.step_id }} ----
    {
      const stepDesc = `{{ s.step_safe }}`;
      const stepId = '{{ s.step_id }}';
      const start = Date.now();
      try {
        {{ s.js_action }}
        await logStep(page, stepId, stepDesc, 'PASS', true);
      } catch (e) {
        console.error(`Step ${s.step_id} failed:`, e);
        await logStep(page, stepId, stepDesc, 'FAIL', true);
        // retry
        try {
          {{ s.js_action }}
          await logStep(page, stepId, stepDesc, 'RETRY_PASS', true);
        } catch (retryErr) {
          console.error(`Retry failed for ${s.step_id}:`, retryErr);
          await logStep(page, stepId, stepDesc, 'RETRY_FAIL', true);
        }
      }
    }
{% endfor %}
  });
{% endfor %}
});
"""

TEST_TEMPLATE_JS = TEST_TEMPLATE_TS  # same body is fine; template will be saved as .js if requested

TS_CONFIG = {
    "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "lib": ["ES2020", "DOM"],
        "strict": False,
        "moduleResolution": "node",
        "esModuleInterop": True,
        "skipLibCheck": True,
        "forceConsistentCasingInFileNames": True,
        "outDir": "dist"
    },
    "include": ["tests/**/*.ts", "pages/**/*.ts"]
}

README_TEMPLATE = """# Generated Playwright Workspace
This workspace was generated by the AI QA Agent.
- Run tests: `npx playwright test`
- To install dependencies (if not already): `npm ci` or `npm install`
- StorageState (session): {{ session_relpath or 'NOT_PROVIDED' }}
"""

# ---------- Utilities ----------
def _escape_for_template(text: str) -> str:
    if not text:
        return ""
    text = text.replace("`", "\\`")  # for template backticks
    text = text.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
    text = re.sub(r"[\r\n]+", " ", text)
    return text.strip()


# ---------- Main Class ----------
class UIFrameworkGenerator:
    """
    Generate an isolated workspace for Playwright tests.
    :param plan: structured AI plan
    :param html_cache_dir: where scraped snapshots exist (for SemanticActionEngine)
    :param output_type: 'ts' or 'js' (default 'ts')
    """
    def __init__(self, plan: dict, html_cache_dir: str = "data/scraped_docs", output_type: str = "ts"):
        assert output_type in ("ts", "js"), "output_type must be 'ts' or 'js'"
        self.plan = plan
        self.semantic_engine = SemanticActionEngine(html_cache_dir=html_cache_dir)
        self.html_cache_dir = html_cache_dir
        self.output_type = output_type

    def _load_latest_html(self) -> str:
        if not os.path.exists(self.html_cache_dir):
            return ""
        files = sorted([f for f in os.listdir(self.html_cache_dir) if f.endswith((".html", ".md"))])
        if not files:
            return ""
        latest = os.path.join(self.html_cache_dir, files[-1])
        with open(latest, "r", encoding="utf-8") as fh:
            return fh.read()

    def _copy_session_into_workspace(self, session_src: Optional[str], workspace_dir: str) -> Optional[str]:
        """Copy the provided session file into workspace/auth/ and return workspace-relative path."""
        if not session_src:
            return None
        # allow relative or absolute input
        if not os.path.exists(session_src):
            candidate = os.path.join(os.getcwd(), session_src)
            if os.path.exists(candidate):
                session_src = candidate
            else:
                return None
        target_dir = os.path.join(workspace_dir, "auth")
        os.makedirs(target_dir, exist_ok=True)
        target_path = os.path.join(target_dir, os.path.basename(DEFAULT_SESSION_RELPATH))
        try:
            shutil.copyfile(session_src, target_path)
            rel = os.path.relpath(target_path, workspace_dir).replace("\\", "/")
            return rel
        except Exception as e:
            print(f"‚ö†Ô∏è Could not copy session into workspace: {e}")
            return None

    def _write_json(self, path: str, data: dict):
        with open(path, "w", encoding="utf-8") as fh:
            json.dump(data, fh, indent=2)

    def generate(self) -> Optional[str]:
        """Main entry ‚Äî returns workspace path or None"""
        if "ui" not in self.plan.get("suites", {}):
            print("‚ÑπÔ∏è No UI suite in plan.")
            return None

        base_url = self.plan.get("project", "").strip()

        # 1) Attempt to obtain or create a session via AuthManager
        session_src = None
        try:
            auth = AuthManager()
            session_src = auth.login_and_save_session()
            if session_src:
                print(f"üîê Reused/created session at: {session_src}")
        except Exception as e:
            print(f"‚ö†Ô∏è AuthManager skipped/failed: {e}")
            session_src = None

        # 2) Create workspace
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        workspace = os.path.join(ROOT_OUT, f"run_{ts}")
        os.makedirs(workspace, exist_ok=True)
        os.makedirs(os.path.join(workspace, "tests"), exist_ok=True)
        os.makedirs(os.path.join(workspace, "pages"), exist_ok=True)
        os.makedirs(os.path.join(workspace, "reports", "step_logs"), exist_ok=True)
        os.makedirs(os.path.join(workspace, "reports", "playwright"), exist_ok=True)

        # 3) Copy session into workspace and compute storage_state line
        session_relpath = self._copy_session_into_workspace(session_src, workspace)
        if session_relpath:
            storage_state_line = f"storageState: process.env.STORAGE_STATE || '{session_relpath}',"
            print(f"üîê Session copied into workspace ‚Üí {session_relpath}")
        else:
            storage_state_line = ""  # omit if none
            print("üîê No session found/copied; tests will run without storageState unless STORAGE_STATE env var is set.")

        # 4) Write playwright.config.js
        config_path = os.path.join(workspace, "playwright.config.js")
        with open(config_path, "w", encoding="utf-8") as fh:
            fh.write(Template(PLAYWRIGHT_CONFIG_TEMPLATE).render(base_url=base_url, storage_state_line=storage_state_line))

        # 5) Build tests from plan
        page_html = self._load_latest_html()

        for suite_name, cases in self.plan["suites"].items():
            if suite_name != "ui":
                continue
            # convert steps
            for case in cases:
                new_steps = []
                for step_str in case.get("steps", []):
                    safe = _escape_for_template(step_str)
                    js_action = self.semantic_engine.generate_js_action(step_str, page_html)
                    new_steps.append({
                        "step_id": str(uuid.uuid4())[:8],
                        "step": step_str,
                        "step_safe": safe,
                        "js_action": js_action
                    })
                case["steps"] = new_steps

            # render test template (TS or JS)
            if self.output_type == "ts":
                rendered = Template(TEST_TEMPLATE_TS).render(suite_name=suite_name, cases=cases)
                suffix = "ts"
            else:
                rendered = Template(TEST_TEMPLATE_JS).render(suite_name=suite_name, cases=cases)
                suffix = "js"

            test_file = os.path.join(workspace, "tests", f"{suite_name}_suite.spec.{suffix}")
            with open(test_file, "w", encoding="utf-8") as fh:
                fh.write(rendered)

        # 6) Write base page object (ts by default)
        if self.output_type == "ts":
            base_page = """\
import { Page, expect } from '@playwright/test';

export class BasePage {
  constructor(public page: Page) {}

  async goto(url: string) {
    await this.page.goto(url);
    await expect(this.page).toHaveTitle(/.*/);
  }

  async verifyTitle() {
    const title = await this.page.title();
    console.log('Title:', title);
    expect(title.length).toBeGreaterThan(0);
  }

  async clickElement(selector: string) {
    await this.page.locator(selector).click();
  }

  async typeInto(selector: string, value: string) {
    await this.page.fill(selector, value);
  }
}
"""
            with open(os.path.join(workspace, "pages", "base.page.ts"), "w", encoding="utf-8") as fh:
                fh.write(base_page)
            # tsconfig
            tsconfig_path = os.path.join(workspace, "tsconfig.json")
            self._write_json(tsconfig_path, TS_CONFIG)
        else:
            base_page_js = """\
/* Simple JS helpers (playwright test) */
exports.BasePage = class BasePage {
  constructor(page) { this.page = page; }
  async goto(url) { await this.page.goto(url); }
  async verifyTitle() { const t = await this.page.title(); console.log('Title', t); }
};
"""
            with open(os.path.join(workspace, "pages", "base.page.js"), "w", encoding="utf-8") as fh:
                fh.write(base_page_js)

        # 7) Write package.json (workspace local)
        pkg = {
            "name": os.path.basename(workspace),
            "version": "1.0.0",
            "description": "AI-generated Playwright workspace",
            "scripts": {
                "test": "npx playwright test"
            },
            "devDependencies": {
                "@playwright/test": "^1.40.0"
            },
            "type": "commonjs"
        }
        self._write_json(os.path.join(workspace, "package.json"), pkg)

        # 8) README & workspace metadata
        with open(os.path.join(workspace, "README.md"), "w", encoding="utf-8") as fh:
            fh.write(Template(README_TEMPLATE).render(session_relpath=session_relpath))

        workspace_meta = {
            "generated_at": datetime.now().isoformat(),
            "project": base_url,
            "session_relpath": session_relpath,
            "output_type": self.output_type,
            "workspace": workspace
        }
        self._write_json(os.path.join(workspace, "workspace_metadata.json"), workspace_meta)

        # 9) Install dependencies (best-effort) and attempt playwright install
        try:
            print("üß© Validating/bootstrapping Playwright inside workspace (this may take a while)...")
            subprocess.run(["npm", "ci"], cwd=workspace, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            # Ensure @playwright/test is present
            node_mod_dir = os.path.join(workspace, "node_modules", "@playwright", "test")
            if not os.path.exists(node_mod_dir):
                # install dev deps
                subprocess.run(["npm", "install", "--save-dev", "@playwright/test"], cwd=workspace, check=True)
            # Try playwright browsers install
            try:
                subprocess.run(["npx", "playwright", "install", "--with-deps"], cwd=workspace, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            except Exception as e:
                print(f"‚ö†Ô∏è 'npx playwright install' had issues: {e} (continuing)")
            print("üì¶ Playwright devDependencies validated in workspace.")
        except Exception as e:
            print(f"‚ö†Ô∏è Dependency bootstrap encountered an error: {e}")

        print(f"‚úÖ Generated Phase 5.4.2 Framework ‚Üí {workspace}/")
        print(f"   - Config: {config_path}")
        print(f"   - Tests: {os.path.join(workspace, 'tests')}/")
        print(f"   - Reports (workspace): {os.path.join(workspace, 'reports')}/")
        print(f"   - Auth session in workspace: {session_relpath or 'NOT_PROVIDED'}")
        return workspace
